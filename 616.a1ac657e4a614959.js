"use strict";(self.webpackChunkTradeoff_V2=self.webpackChunkTradeoff_V2||[]).push([[616],{490:(_,f,l)=>{l.d(f,{Z:()=>T});var h=l(861);function i(a,e){let t=a.length-e,d=0;do{for(let s=e;s>0;s--)a[d+e]+=a[d],d++;t-=e}while(t>0)}function w(a,e,t){let d=0,s=a.length;const r=s/t;for(;s>e;){for(let n=e;n>0;--n)a[d+e]+=a[d],++d;s-=e}const c=a.slice();for(let n=0;n<r;++n)for(let o=0;o<t;++o)a[t*n+o]=c[(t-o-1)*r+n]}class T{decode(e,t){var d=this;return(0,h.Z)(function*(){const s=yield d.decodeBlock(t),r=e.Predictor||1;if(1!==r){const c=!e.StripOffsets;return function g(a,e,t,d,s,r){if(!e||1===e)return a;for(let o=0;o<s.length;++o){if(s[o]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(s[o]!==s[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const c=s[0]/8,n=2===r?1:s.length;for(let o=0;o<d&&!(o*n*t*c>=a.byteLength);++o){let u;if(2===e){switch(s[0]){case 8:u=new Uint8Array(a,o*n*t*c,n*t*c);break;case 16:u=new Uint16Array(a,o*n*t*c,n*t*c/2);break;case 32:u=new Uint32Array(a,o*n*t*c,n*t*c/4);break;default:throw new Error(`Predictor 2 not allowed with ${s[0]} bits per sample.`)}i(u,n)}else 3===e&&(u=new Uint8Array(a,o*n*t*c,n*t*c),w(u,n,c))}return a}(s,r,c?e.TileWidth:e.ImageWidth,c?e.TileLength:e.RowsPerStrip||e.ImageLength,e.BitsPerSample,e.PlanarConfiguration)}return s})()}}},616:(_,f,l)=>{l.r(f),l.d(f,{default:()=>i});var h=l(490);class i extends h.Z{decodeBlock(g){return g}}}}]);