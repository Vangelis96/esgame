"use strict";(self.webpackChunkTradeoff_V2=self.webpackChunkTradeoff_V2||[]).push([[227],{490:(I,p,E)=>{E.d(p,{Z:()=>U});var L=E(861);function C(l,c){let i=l.length-c,d=0;do{for(let t=c;t>0;t--)l[d+c]+=l[d],d++;i-=c}while(i>0)}function y(l,c,i){let d=0,t=l.length;const s=t/i;for(;t>c;){for(let n=c;n>0;--n)l[d+c]+=l[d],++d;t-=c}const o=l.slice();for(let n=0;n<s;++n)for(let e=0;e<i;++e)l[i*n+e]=o[(i-e-1)*s+n]}class U{decode(c,i){var d=this;return(0,L.Z)(function*(){const t=yield d.decodeBlock(i),s=c.Predictor||1;if(1!==s){const o=!c.StripOffsets;return function T(l,c,i,d,t,s){if(!c||1===c)return l;for(let e=0;e<t.length;++e){if(t[e]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(t[e]!==t[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const o=t[0]/8,n=2===s?1:t.length;for(let e=0;e<d&&!(e*n*i*o>=l.byteLength);++e){let a;if(2===c){switch(t[0]){case 8:a=new Uint8Array(l,e*n*i*o,n*i*o);break;case 16:a=new Uint16Array(l,e*n*i*o,n*i*o/2);break;case 32:a=new Uint32Array(l,e*n*i*o,n*i*o/4);break;default:throw new Error(`Predictor 2 not allowed with ${t[0]} bits per sample.`)}C(a,n)}else 3===c&&(a=new Uint8Array(l,e*n*i*o,n*i*o),y(a,n,o))}return l}(t,s,o?c.TileWidth:c.ImageWidth,o?c.TileLength:c.RowsPerStrip||c.ImageLength,c.BitsPerSample,c.PlanarConfiguration)}return t})()}}},227:(I,p,E)=>{E.r(p),E.d(p,{default:()=>d});var L=E(490);const C=9,y=256,T=257,U=12;function c(t,s){for(let o=s.length-1;o>=0;o--)t.push(s[o]);return t}class d extends L.Z{decodeBlock(s){return function i(t){const s=new Uint16Array(4093),o=new Uint8Array(4093);for(let r=0;r<=257;r++)s[r]=4096,o[r]=r;let n=258,e=C,a=0;function k(){n=258,e=C}function g(r){const A=function l(t,s,o){const n=s%8,e=Math.floor(s/8),a=8-n,k=s+o-8*(e+1);let g=8*(e+2)-(s+o);const v=8*(e+2)-s;if(g=Math.max(0,g),e>=t.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),T;let _=t[e]&2**(8-n)-1;_<<=o-a;let u=_;if(e+1<t.length){let h=t[e+1]>>>g;h<<=Math.max(0,o-v),u+=h}return k>8&&e+2<t.length&&(u+=t[e+2]>>>8*(e+3)-(s+o)),u}(r,a,e);return a+=e,A}function v(r,A){return o[n]=A,s[n]=r,n++,n-1}function _(r){const A=[];for(let B=r;4096!==B;B=s[B])A.push(o[B]);return A}const u=[];k();const h=new Uint8Array(t);let w,f=g(h);for(;f!==T;){if(f===y){for(k(),f=g(h);f===y;)f=g(h);if(f===T)break;if(f>y)throw new Error(`corrupted code at scanline ${f}`);c(u,_(f)),w=f}else if(f<n){const r=_(f);c(u,r),v(w,r[r.length-1]),w=f}else{const r=_(w);if(!r)throw new Error(`Bogus entry. Not in dictionary, ${w} / ${n}, position: ${a}`);c(u,r),u.push(r[r.length-1]),v(w,r[r.length-1]),w=f}n+1>=2**e&&(e===U?w=void 0:e++),f=g(h)}return new Uint8Array(u)}(s).buffer}}}}]);